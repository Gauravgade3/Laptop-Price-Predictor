# -*- coding: utf-8 -*-
"""Laptop_Price_Predictor.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1eB-DYrO2W_TxDnMSBtzcFAdhQEGZAxTY
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
from statsmodels.stats.outliers_influence import variance_inflation_factor

# %matplotlib inline
import warnings
warnings.filterwarnings("ignore")

df=pd.read_csv('/content/drive/MyDrive/Datasets/laptops.csv',encoding = "ISO-8859-1")

df.shape

df.head()

df.tail()

df.info()

df.describe()

df.isnull().sum()

df.duplicated().sum()

df.drop_duplicates(keep=False,inplace=True)

df['Ram'] = df['RAM'].str.replace("GB", "").astype('int32')

df['Weight'] = df['Weight'].str.replace("kgs","").str.replace("kg","").astype(float)

df['Operating System'] = df['Operating System'].str.replace("macOS","Mac OS")

df['Gpu'] = df['GPU'].apply(lambda x:x.split()[0])

df['Screen Size'] = df['Screen Size'].str[:-1].astype(float)

df['Touchscreen'] = df['Screen'].apply(lambda x:1 if 'Touchscreen' in x else 0)
df['Ips'] = df['Screen'].apply(lambda x:1 if 'IPS' in x else 0)

def fetch_processor(x):
  cpu_name = " ".join(x.split()[0:3])
  if cpu_name == 'Intel Core i7' or cpu_name == 'Intel Core i5' or cpu_name == 'Intel Core i3':
    return cpu_name
  elif cpu_name.split()[0] == 'Intel':
    return 'Other Intel Processor'
  else:
    return 'AMD Processor'
df['Cpu'] = df['CPU'].apply(lambda x: fetch_processor(x))

df["Storage"] = df[" Storage"].str.replace('GB', '')
df["Storage"] = df["Storage"].str.replace('TB', '000')

new= df["Storage"].str.split("+", n = 1, expand = True)
df["first"]= new[0]
df["second"]= new[1]
df["Layer1HDD"] = df["first"].apply(lambda x: 1 if "HDD" in x else 0)
df["Layer1SSD"] = df["first"].apply(lambda x: 1 if "SSD" in x else 0)
df["Layer1Hybrid"] = df["first"].apply(lambda x: 1 if "Hybrid" in x else 0)
df["Layer1Flash_Storage"] = df["first"].apply(lambda x: 1 if "Flash Storage" in x else 0)
df['first'] = df['first'].str.replace(r'\D', '')
df["second"].fillna("0", inplace = True)

df["Layer2HDD"] = df["second"].apply(lambda x: 1 if "HDD" in x else 0)
df["Layer2SSD"] = df["second"].apply(lambda x: 1 if "SSD" in x else 0)
df["Layer2Hybrid"] = df["second"].apply(lambda x: 1 if "Hybrid" in x else 0)
df["Layer2Flash_Storage"] = df["second"].apply(lambda x: 1 if "Flash Storage" in x else 0)
df['second'] = df['second'].str.replace(r'\D', '')

df["first"] = df["first"].astype(int)
df["second"] = df["second"].astype(int)

df["HDD"]=(df["first"]*df["Layer1HDD"]+df["second"]*df["Layer2HDD"])
df["SSD"]=(df["first"]*df["Layer1SSD"]+df["second"]*df["Layer2SSD"])
df["Hybrid"]=(df["first"]*df["Layer1Hybrid"]+df["second"]*df["Layer2Hybrid"])
df["Flash_Storage"]=(df["first"]*df["Layer1Flash_Storage"]+df["second"]*df["Layer2Flash_Storage"])

df["HDD"].fillna("0", inplace = True)

df.drop(columns=['first', 'second', 'Layer1HDD', 'Layer1SSD', 'Layer1Hybrid',
       'Layer1Flash_Storage', 'Layer2HDD', 'Layer2SSD', 'Layer2Hybrid',
       'Layer2Flash_Storage'],inplace=True)

df.drop(columns=['Storage'],inplace=True)

def findXresolution(s):
  return s.split()[-1].split("x")[0]
def findYresolution(s):
  return s.split()[-1].split("x")[1]

#finding the x_res and y_res from screen resolution
df['X_res'] = df['Screen'].apply(lambda x: findXresolution(x))
df['Y_res'] = df['Screen'].apply(lambda y: findYresolution(y))

#convert to numeric
df['X_res'] = df['X_res'].astype('int')
df['Y_res'] = df['Y_res'].astype('int')

df["Price"] = df["Price (Euros)"].str.replace(',', '').astype(float)


df['ppi'] = (((df['X_res']**2) + (df['Y_res']**2))**0.5/df['Screen Size']).astype('float')

df.drop(columns=['Price (Euros)','X_res','Y_res','Screen','Operating System Version','Screen Size','CPU','GPU','RAM','Model Name','Hybrid','Flash_Storage'],inplace=True)

df.drop(df[(df['Manufacturer'] == "Samsung") | (df['Manufacturer'] =="Google") | (df['Manufacturer'] =="Razer") | (df['Manufacturer'] =="Mediacom") | (df['Manufacturer'] =="Microsoft") | (df['Manufacturer'] =="Xiaomi") | (df['Manufacturer'] =="Vero") | (df['Manufacturer'] =="Chuwi") | (df['Manufacturer'] =="Fujitsu") | (df['Manufacturer'] =="LG") | (df['Manufacturer'] =="Huawei")].index, inplace = True)

#checking correlation using heatmap
plt.rcParams['figure.figsize']=(12,10)
sns.heatmap(df.corr(), cmap="YlGnBu", annot=True)

numeric_features= df.select_dtypes(exclude='object')

numeric_features.describe()

#plotting histogram

for col in numeric_features[:]:
  sns.histplot(df[col])
  plt.axvline(df[col].mean(), color='magenta', linestyle='dashed', linewidth=2)
  plt.axvline(df[col].median(), color='cyan', linestyle='dashed', linewidth=2)  
  plt.figure(figsize=(10,7))

# ploting Regression plot of each columns of dataset v/s Price columns

for col in numeric_features[:]:
  plt.figure(figsize=(10,7))

  if col == 'Price':
    pass
  else:
    sns.regplot(x=df[col],y=df["Price"],line_kws={"color": "red"})

#Extracting categorical features
categorical_features= df.select_dtypes(include='object')

for col in categorical_features:
  plt.figure(figsize=(15,8))
  sns.boxplot(x=df[col],y=df["Price"])

df.head()

df.sample(5)

df.info()

#visualising distribution

plt.figure(figsize=(15,10))
sns.distplot((df['Price']),color="y")

# square_root transformation
plt.figure(figsize=(15,10))
sns.distplot(np.log(df['Price']),color="y")

X = df.drop(columns=['Price'])
y = np.log(df['Price'])

X

y

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test= train_test_split(X, y, test_size = 0.15, random_state = 0)

X_train

from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import OneHotEncoder
from sklearn.metrics import r2_score, mean_absolute_error

from sklearn.linear_model import LinearRegression, Lasso, Ridge
from sklearn.ensemble import RandomForestRegressor, GradientBoostingRegressor
from xgboost import XGBRegressor

"""# **Linear Regression**"""

step1 = ColumnTransformer(transformers = [('col_tnf', OneHotEncoder(sparse = False, drop = 'first'), [0,1,2,5,8])], remainder = 'passthrough')

step2 = LinearRegression()
pipe = Pipeline([('step1', step1), ('step2', step2)])
pipe.fit(X_train,y_train)
y_pred=pipe.predict(X_test)
print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

"""# **Lasso**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,2,5,8])
],remainder='passthrough')

step2 = Lasso(alpha=0.001)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

"""# **Ridge**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,2,5,8])
],remainder='passthrough')

step2 = Ridge(alpha=5)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

"""# **Random Forest**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,2,5,8])
],remainder='passthrough')

step2 = RandomForestRegressor(n_estimators=100,
                              random_state=3,
                              max_samples=0.5,
                              max_features=0.75,
                              max_depth=15)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

"""# **Gradient Boost**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,2,5,8])
],remainder='passthrough')

step2 = GradientBoostingRegressor(n_estimators=500)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

"""# **XGBoost**"""

step1 = ColumnTransformer(transformers=[
    ('col_tnf',OneHotEncoder(sparse=False,drop='first'),[0,1,2,5,8])
],remainder='passthrough')

step2 = XGBRegressor(n_estimators=45,max_depth=5,learning_rate=0.5)

pipe = Pipeline([
    ('step1',step1),
    ('step2',step2)
])

pipe.fit(X_train,y_train)

y_pred = pipe.predict(X_test)

print('R2 score',r2_score(y_test,y_pred))
print('MAE',mean_absolute_error(y_test,y_pred))

import pickle

pickle.dump(df,open('df.pkl','wb'))
pickle.dump(pipe,open('pipe.pkl','wb'))